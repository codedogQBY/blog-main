'use client';

import { useEffect } from 'react';

export function ServiceWorkerCleanup() {
  useEffect(() => {
    // åªåœ¨æ”¯æŒService Workerçš„æµè§ˆå™¨ä¸­æ‰§è¡Œ
    if (typeof window !== 'undefined' && 'serviceWorker' in navigator) {
      // æ£€æŸ¥æ˜¯å¦å·²ç»æ¸…ç†è¿‡ï¼Œé¿å…é‡å¤æ‰§è¡Œ
      const hasCleanedUp = localStorage.getItem('sw-cleanup-completed');
      const lastCleanup = hasCleanedUp ? parseInt(hasCleanedUp) : 0;
      const oneDay = 24 * 60 * 60 * 1000; // 24å°æ—¶
      
      // å¦‚æœè¶…è¿‡24å°æ—¶æˆ–ä»æœªæ¸…ç†è¿‡ï¼Œåˆ™æ‰§è¡Œæ¸…ç†
      if (!hasCleanedUp || (Date.now() - lastCleanup) > oneDay) {
        cleanupServiceWorker();
      }
    }
  }, []);

  const cleanupServiceWorker = async () => {
    try {
      console.log('å¼€å§‹æ¸…ç†Service Worker...');

      // 1. è·å–æ‰€æœ‰å·²æ³¨å†Œçš„Service Worker
      const registrations = await navigator.serviceWorker.getRegistrations();
      console.log('æ‰¾åˆ°çš„Service Workeræ³¨å†Œ:', registrations.length);

      if (registrations.length === 0) {
        console.log('æ²¡æœ‰æ‰¾åˆ°å·²æ³¨å†Œçš„Service Worker');
        return;
      }

      // 2. é¦–å…ˆæ³¨å†Œæ¸…ç†ç”¨çš„Service Worker
      let cleanupRegistration: ServiceWorkerRegistration | undefined;
      try {
        cleanupRegistration = await navigator.serviceWorker.register('/sw-cleanup.js', {
          scope: '/'
        });
        console.log('æ¸…ç†Service Workeræ³¨å†ŒæˆåŠŸ');

        // ç­‰å¾…æ¸…ç†SWæ¿€æ´»
        if (cleanupRegistration && cleanupRegistration.installing) {
          await new Promise((resolve) => {
            cleanupRegistration!.installing!.addEventListener('statechange', () => {
              if (cleanupRegistration!.installing!.state === 'activated') {
                resolve(void 0);
              }
            });
          });
        }

        // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©æ¸…ç†SWå®Œæˆç¼“å­˜æ¸…ç†
        await new Promise(resolve => setTimeout(resolve, 1000));

        // 3. å‘æ¸…ç†SWå‘é€æ³¨é”€æ¶ˆæ¯
        if (cleanupRegistration && cleanupRegistration.active) {
          const channel = new MessageChannel();
          const unregisterPromise = new Promise((resolve) => {
            channel.port1.onmessage = (event) => {
              console.log('æ”¶åˆ°æ¸…ç†SWçš„æ³¨é”€å“åº”:', event.data);
              resolve(event.data.success);
            };
          });

          cleanupRegistration.active.postMessage(
            { type: 'UNREGISTER' },
            [channel.port2]
          );

          await unregisterPromise;
        }
      } catch (error) {
        console.warn('æ³¨å†Œæ¸…ç†Service Workerå¤±è´¥:', error);
      }

      // 4. æ³¨é”€æ‰€æœ‰Service Workerï¼ˆåŒ…æ‹¬æ¸…ç†SWï¼‰
      const unregisterPromises = registrations.map(async (registration) => {
        try {
          const success = await registration.unregister();
          console.log(`æ³¨é”€Service Worker ${registration.scope}:`, success);
          return success;
        } catch (error) {
          console.warn(`æ³¨é”€Service Worker ${registration.scope} å¤±è´¥:`, error);
          return false;
        }
      });

      await Promise.all(unregisterPromises);

      // 5. æ‰‹åŠ¨æ¸…ç†æ‰€æœ‰ç¼“å­˜å­˜å‚¨
      if ('caches' in window) {
        try {
          const cacheNames = await caches.keys();
          console.log('æ‰¾åˆ°çš„ç¼“å­˜:', cacheNames);
          
          const deletePromises = cacheNames.map(async (cacheName) => {
            try {
              const deleted = await caches.delete(cacheName);
              console.log(`åˆ é™¤ç¼“å­˜ ${cacheName}:`, deleted);
              return deleted;
            } catch (error) {
              console.warn(`åˆ é™¤ç¼“å­˜ ${cacheName} å¤±è´¥:`, error);
              return false;
            }
          });

          await Promise.all(deletePromises);
        } catch (error) {
          console.warn('æ¸…ç†ç¼“å­˜å¤±è´¥:', error);
        }
      }

      // 6. æ¸…ç†localStorageä¸­çš„SWç›¸å…³æ•°æ®
      try {
        const swKeys = [
          'sw-version',
          'sw-cache-version',
          'workbox-runtime',
          'workbox-precache',
          // æ·»åŠ å…¶ä»–å¯èƒ½çš„SWç›¸å…³key
        ];

        swKeys.forEach(key => {
          if (localStorage.getItem(key)) {
            localStorage.removeItem(key);
            console.log(`æ¸…ç†localStorage: ${key}`);
          }
        });
      } catch (error) {
        console.warn('æ¸…ç†localStorageå¤±è´¥:', error);
      }

      // 7. æ¸…ç†sessionStorageä¸­çš„SWç›¸å…³æ•°æ®
      try {
        const swKeys = [
          'sw-session',
          'workbox-session',
          // æ·»åŠ å…¶ä»–å¯èƒ½çš„SWç›¸å…³key
        ];

        swKeys.forEach(key => {
          if (sessionStorage.getItem(key)) {
            sessionStorage.removeItem(key);
            console.log(`æ¸…ç†sessionStorage: ${key}`);
          }
        });
      } catch (error) {
        console.warn('æ¸…ç†sessionStorageå¤±è´¥:', error);
      }

      console.log('Service Workeræ¸…ç†å®Œæˆ');

      // 8. é™é»˜å®Œæˆæ¸…ç†ï¼Œé¿å…æ‰“æ‰°ç”¨æˆ·
      // è®¾ç½®ä¸€ä¸ªæ ‡è®°ï¼Œè¡¨ç¤ºå·²ç»å®Œæˆæ¸…ç†
      const hasCleanedUp = localStorage.getItem('sw-cleanup-completed');
      if (!hasCleanedUp) {
        localStorage.setItem('sw-cleanup-completed', Date.now().toString());
        console.log('âœ… Service Workerå’Œç¼“å­˜æ¸…ç†å®Œæˆ');
        console.log('ğŸ“ å¦‚æœé‡åˆ°ä»»ä½•é¡µé¢æ˜¾ç¤ºé—®é¢˜ï¼Œè¯·åˆ·æ–°é¡µé¢');
      }

    } catch (error) {
      console.error('Service Workeræ¸…ç†è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
    }
  };

  // è¿™ä¸ªç»„ä»¶ä¸æ¸²æŸ“ä»»ä½•å†…å®¹
  return null;
}

export default ServiceWorkerCleanup; 